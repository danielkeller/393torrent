\documentclass[letter]{scrartcl}
\usepackage{graphicx}
\usepackage{fullpage} %1in margins
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{tikz} % for diagrams
\usetikzlibrary{automata,positioning}

\newcommand{\app}{\textsc{393torrent}}

\begin{document}

\title{Requirements for \app}
\subtitle{Dan Keller, Kenneth Link, Nathan McKinley, Ross Nanopoulos}
\date{} % no date

\maketitle

\begin{abstract}
The design document details the structure and low-level functioning of the software. It it written to fulfill the requirements specification, and to guide the implementation of the software. If some part of the design changes, the document must be changed as well to reflect it. The document is also used to facilitate maintenance of the software.
\end{abstract}

\tableofcontents
\pagebreak

\section{Overview}
The BitTorrent client (\app) will allow users to download, create, and seed torrent files.  It will enable them to achieve the full functionality of a BitTorrent client in a lightweight form.  The primary objective of this BitTorrent client is to offer a free and open source alternative--without advertisements--to the current heavyweight clients available.  Specific goals of 393torrent can be found in the vision and scope document.

\section{Bittorrent Protocol}

\subsection{Protocol Overview}
	
Bittorrent is a file transfer protocol created by Bram Cohen intended for sending files over unreliable networks.  A torrent is a collection of peers who are participating in the distribution of a file.  To achieve a reliable download protocol over unreliable networks, bittorrent uses many peers who send and receive small equi-sized “chunks” of data (typically 256KB).  A peer joins a torrent by registering with something called the tracker.  The tracker keeps track of all peers participating in the torrent and requires updates from each peer to continue tracking them.  The number of peers can be anything from one to thousands of peers, however the more peers the faster the download speed which is opposite of server hosted downloads.  After the tracker becomes aware of a new peer it sends that user (User A) a list of ip addresses of other peers on the torrent.  User A will attempt to connect via TCP to each of the peers obtained from the list and exchange a list of missing chunks with that peer.  With the new knowledge of which peer has the chunks that User A is missing, User A can request the rarest chunks first (a chunk that most of her peers do not have but at least one peer does have).  After the rarest first have been taken care of, User A will continue trading chunks with peers who are currently supplying User A with the highest data rate.  Also, every 10 seconds User A will recalculate the download rates and update the list of highest data rate peers.  Additionally every 30 seconds User A chooses one peer by random and sends a chunk to it. 

\subsection{Tracker}
	The tracker is a database of peers which responds to HTTP GET requests.  These requests can return tracker statistics and a list of peer ip addresses.

\begin{figure}[ht!]
\centering
\includegraphics[width=120mm]{infographic.jpg}
\caption{Tracker infographic}
\label{overflow}
\end{figure}

Typical tracker requests may include the following parameters:
\begin{itemize}
\item info\_hash: urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file
\item peer\_id: urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup
\item port: Port Number being used to listen for messages
\item uploaded: Total number of data sent since the client sent the 'started' event to the tracker in base ten ASCII.
\item downloaded:  Total amount of data downloaded since the client sent the 'started' event to the tracker in base ten ASCII
\item left: Number of bytes still needed to complete the download in base ten ASCII.
\item compact: Returns a compact string if this is set to 1
\item no\_peer\_id: Tracker may omit the peer id field
\item event:  If used, must be one of: started, completed, stopped.
\item ip: Optional. The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 address
\item numwant: Optional. Number of participating peers that should be returned by the tacker. This value is permitted to be zero. If omitted, typically defaults to 50 peers.
\item key: Optional. An identification mechanism for people who's ip address may change. 
\item trackerid: Optional. If a previous announce contained a tracker id, it should be set here.
\end{itemize}

Trackers answer a request with a response containing a plaintext document which contains a bencoded dictionary with these keys:
\begin{itemize}
\item failure reason: When returned, This response contains a string of .
\item warning message: Optional. A failure reason that still gets processed normally. The warning message is shown just like an error.
\item interval: The interval used to determine time between tracker requests.
\item min interval: Optional. If used clients will not reannounce faster than this interval.
\item tracker id: On the next announcment, the clinet will send this string value.
\item complete: Integer for number of seeders
\item incomplete: Integer of nonseeders (leechers)
\item peers: (dictionary model) The value is a list of dictionaries, each with the following keys:
\item peer id: peer's self-selected ID, as described above for the tracker request (string)
\item ip: peer's IP address either IPv6 (hexed) or IPv4 (dotted quad) or DNS name (string)
\item port: peer's port number (integer)
\item peers: (binary model) Instead of using the dictionary model described above, the peers value may be a string consisting of multiples of 6 bytes. First 4 bytes are the IP address and last 2 bytes are the port number. All in network (big endian) notation.
\end{itemize}
\subsection{Peer Wire Protocol TCP}

In TCP, a client must remember state information such as:

\begin{itemize}
\item choked: Lets other peers know that notification requests won't be answered until the client is unchoked.
\item interested: if the user is interested in a chunk the other peer has to offer
\item am\_choking: this client is choking the peer
\item am\_interested: this client is interested in the peer
\item peer\_choking: peer is choking this client
\item peer\_interested: peer is interested in this client
Client connections start out as "choked" and "not interested". In other words:
\item am\_choking = 1
\item am\_interested = 0
\item peer\_choking = 1
\item peer\_interested = 0
\end{itemize}

\subsection{Handshake}
The first message sent by a client is the handshake.  This is done before any connection is established between peers. 
\begin{itemize}
\item pstrlen: string length of pstr, as a single raw byte
\item pstr: string identifier of the protocol
\item reserved: eight (8) reserved bytes. All current implementations use all zeroes. Each bit in these bytes can be used to change the behavior of the protocol. An email from Bram suggests that trailing bits should be used first, so that leading bits may be used to change the meaning of trailing bits.
\item info\_hash: 20-byte SHA1 hash of the info key in the metainfo file. This is the same info\_hash that is transmitted in tracker requests.
\item peer\_id: 20-byte string used as a unique ID for the client. This is usually the same peer\_id that is transmitted in tracker requests (but not always e.g. an anonymity option in Azureus).
\end{itemize}
\subsection{Advantages}

As opposed to traditional file distribution methods, Bittorrent has fasted distribution time which increases as the number of users increases because a high number of peers means there  will be a more efficient use of bandwidth. 

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{Graph.jpg}
\caption{Distribution time vs peers}
\label{overflow}
\end{figure}

Wiki.theory.org Contributors. (2013 July 26) `` ''Bittorrent Protocol Specification v1.0`` ''. [Online]. Available: https://wiki.theory.org/BitTorrentSpecification

Ross Kurose. `` ''Chapter 2 Application Layer`` ''. Computer Networking A Top-Down Approach 6th edition

\section{App Architecture}
A single run of this application will progress through three stages.  They are, in brief, the torrent acquisition stage, the file download stage, and the file seeding stage.  In the first stage, the application will determine what trackers it should connect to, and which files it is attempting to download.  The output of this stage will be an object containing the trackers that will be used for this torrent download, and the information about the torrent download itself.  This output is used as input to the second stage of the application run, which will proceed with the connections to peers and begin downloading individual "pieces" (as defined by the bittorrent spec) from those peers.  After several sequential pieces have been received, those will be combined into a "part", which will be saved to disk.  After all pieces have been downloaded, the parts which have been saved to disk will be combined into the output file.  In the final stage, the pieces will be served to other peers which request them.

This third stage will begin at the same time as the second stage, since pieces which have been downloaded already can be served up even before the entire file has been received.  In some sense, this is the reason that the bittorrent protocol leads to decreased time to complete a download.  It will also be continued after download is complete, if the user has specified that they would like to continue seeding indefinitely.

\begin{figure}[h]
\centering
\includegraphics[scale=.5]{stageDiagram.png}
\caption{The three stages of an application run}
\end{figure}

\subsection{Torrent Acquisition Stage}

\begin{figure}[h]
\centering
\includegraphics[scale=.5]{StepOne.png}
\caption{The four objects involved in the first stage of an application run}
\end{figure}

In this first stage of an application run, the TorrentApplication (our main class) will create a TorrentFileRetriever.  This object is responsible for understanding the command-line arguments passed to the application, whether they be a magnet link or the location of a file in the filesystem.  Since we seek to be cross-platform, we will need to defer to the OS for this kind of understanding; we'll need to understand '/home/username/something.torrent' on unix as well as as 'C:\textbackslash Documents And Settings\textbackslash Username\textbackslash something.torrent' on Windows.  This is easily possible due to python's os.path module, which understands cross-platform filenames.\\

The TorrentFileRetriever will either read or download information about the torrent that the user seeks to download, depending on input.  In either case, it will return a TorrentFileInfo object, which will contain information that the rest of the application will require in order to function.  This information includes the SHA1 hash of the 'info' dict contained in the .torrent file, as well as several other key pieces of information (announce URL, etc).  See Section One for details on the information which will need to be present.\\

Very important in this TorrentFileInfo object will be a Tracker object, which will have the capability to connect to the torrent tracker(s) specified in the .torrent file.  There are very specific messages that need to be sent to the trackers at intervals during download; the Tracker object will be capable of sending these and reading their responses.

\subsection{File Download Stage}

\begin{figure}[h]
\centering
\includegraphics[scale=.5]{StepTwo.png}
\caption{The objects involved in the second stage of an application run}
\end{figure}

The second stage begins immediately after the first stage completes.   In this stage, the TorrentApplication creates a TorrentDownloader which is responsible for downloading the contents of the torrent.  The TorrentDownloader takes in a TorrentFileInfo object which has information about available trackers.  When the number of active peers falls below a preconfigured threshold (choice of this threshold has been empirically shown to affect performance, 30 is a good default), the TorrentDownloader will query the trackers for additional peers, and create Peer objects for each of these peers.  These Peer objects are responsible for handling communication with the peers, coordinated by the TorrentDownloader.  This central coordination will ensure that no file pieces are downloaded multiple times.\\

One operation available on Peer objects will be the download\_piece(int piece\_num) operation.  When a piece finishes downloading, a FilePiece object will be created.  Over time, FilePiece objects will be collected into FilePart objects (in order to reduce disk writes), which will be serialized to disk.  Once all pieces are done downloading (a condition recognized by the TorrentDownloader), the FilePart objects will be loaded, one by one, and have their contents written into the file(s) that the .torrent file specifies.

\subsection{File Seeding Stage}
\begin{figure}[h]
\centering
\includegraphics[scale=.5]{StepThree.png}
\caption{The objects involved in the third stage of an application run}
\end{figure}

The third stage begins immediately after the first stage completes, and may live indefinitely (until killed) if the user specifies on the command line that they wish to seed indefinitely.  In this stage, the TorrentApplication creates a TorrentUploader, which loads the state of the download from disk (by reading the FilePieces).  It then opens a port for connections from peers (by default, this port will be 6881, but this will be configurable), and waits for connections to begin.  When connections are initiated, the TorrentUploader will create new Peer objects for each connection (since peers are allowed only one connection each) and will serve requests by reading the FilePieces from disk.  This is done to reduce memory overhead; if the FilePieces were held in memory so that upload requests would not cause disk reads, we would need to hold at least the total filesize in memory.  Since torrents are often used for very large downloads (in some cases, multiple terabytes), this is infeasible.

\section{Thread Model}
\begin{figure}[h]
\centering
\includegraphics[scale=.5]{threads.png}
\caption{Communication between threads}
\end{figure}

As this is a network application, threads are used to wait for communication from other hosts. The three main threads are the accept loop, the recv loop, and the main loop.

\subsection{Accept Thread}
The purpose of the accept loop is to wait on incoming connections from peers. The TorrentDownloader object sets up a listening socket on port 6881, and then spawns this thread. The thread calls \texttt{accept}, and sleeps until it recieves a connection, at which point it spawns a new Peer object for the connection, and calls accept again. The Peer is placed in a global list of peers, for the main loop to process.

\subsection{Recv Thread}
The purpose of the recv loop is to wait for incoming data from peers. It recieves messages regarding choking and unchoking, as well as interest and disinterest, and stores them in the peer's internal state.

Additionally, it recieves piece data, and forwards this data to the main loop for processing and storage. Pieces are placed in a concurrent queue, and the main loop takes them and assigns them to FileParts.

Each thread blocks on a recv call on its respective peer.

\subsection{Main Thread}
The main loop handles all functionality that doesn't need to be in a separate thread. It tracks what parts of the file have been downloaded, and decides which peers to send requests to. Although the recv loop gets messages from peers, the main loop sends them. Additionally, it controls the interested and choked state of the peers.

The main loop also controls communication with the tracker, and initiates connections to peers. Thus, both the main loop and the accept loop create Peer objects. 

The main thread, unlike the other threads, does not block on an socket api call. Rather, it connects to peers until it determines it has connected to enough, and then blocks until either
\begin{enumerate}
\item The accept thread creates a new peer, and the program needs to know if the peer should be communicated with at this time. Peer's constructor will wake up the thread.
\item A peer changes its choking or interest state and wakes up the main thread.
\item A piece arrives.
\end{enumerate}
Once the thread has woken up, it will determine if its state has changed in a way that warrents further action.

\section{Classes in Detail}

\pagebreak
\section{Author Contributions}
This section provides the details to what each author contributed to the vision and scope document, as requested per professor Podgurski.
\subsection{Daniel Keller}
Created document outline and threading model.
\subsection{Kenneth Link}
Kenneth Created the Protocol secttion
\subsection{Nathan McKinley}
Nathan McKinley created the app architecture section and diagrams.
\subsection{Ross Nanopoulos}


\section{Inspection}
\begin{tabularx}{\textwidth}{X c c}
\textbf{Comment} & \textbf{Reported By} & \textbf{Fixed By} \\
No Issues seen& Kenneth Link& N/A \\
Abstract is for wrong document & Dan Keller & Dan Keller \\
\end{tabularx}
\end{document}
